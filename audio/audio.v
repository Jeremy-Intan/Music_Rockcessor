
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module audio(

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);


//TODO: make it less of a vaccuum cleaner/random
// figure out why it's only playing during reset (queue over filled/not reading?)
// make buttons do different frequencies to DAC while switches control frequency?

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire audio_rst;
wire [15:0] amplitude1;
wire [15:0] amplitude2;
wire [15:0] amplitude;

reg [1:0] write_addr;
reg [4:0] counter = 0;
reg [4:0] counter_depth;


//=======================================================
//  Structural coding
//=======================================================

//
//assign amplitude1 = (counter == 0) ? 16'hFFFF : 16'h0000;

//assign amplitude2 = (counter == 0) ? 16'h7FFF : 16'h0000;

//assign amplitude = (KEY[1]) ? amplitude1 : amplitude1;

assign amplitude = (counter == 0) ? (~KEY[1]) ? 16'h7FFF : (~KEY[2]) ? 16'h5FFF : (~KEY[3]) ? 16'h3FFF : 16'h0000 : 16'h0000;

assign LEDR[0] = ~KEY[0];

// evenly spread to left and right buffer
always @ (posedge CLOCK_50) begin
	counter_depth <= (SW[0]) ? 32 : (SW[1]) ? 30 : (SW[2]) ? 28 : (SW[3]) ? 26 : (SW[4]) ? 24 : (SW[5]) ? 22 : (SW[6]) ? 20 : (SW[7]) ? 18 : (SW[8]) ? 16 : (SW[9]) ? 14 : 12;

	
	//12: 3055hz
	//14: 2662
	//16: 
	//18: 
	
	
	
	
	
	
	
	if (counter >= counter_depth) counter <= 0;
	else counter <= counter + 1;
	
//	write_addr <= 2'b10;
	if (write_addr == 2'b10)
		write_addr <= 2'b11;
	else
		write_addr <= 2'b10;
end



// IP to generate a slower clock for the AV chip
audio_clk (
		.audio_clk_clk(AUD_XCK),      //    audio_clk.clk
		.ref_clk_clk(CLOCK_50),        //      ref_clk.clk
		.ref_reset_reset(~KEY[0]),    //    ref_reset.reset
		.reset_source_reset(audio_rst)  // reset_source.reset
	);

// IP to output through AV chip
audio_output (
		.address(write_addr),     // avalon_audio_slave.address
		.chipselect(1'b1),  //                   .chipselect
//		input  wire        read,        //                   .read
		.write(1'b1),       //                   .write
		//.writedata({16'b0,amplitude}),   //                   .writedata
		.writedata({16'b0,amplitude}),
//		output wire [31:0] readdata,    //                   .readdata
		//.clk(AUD_XCK),         //                clk.clk
		.clk(CLOCK_50),
		.AUD_BCLK(AUD_BCLK),    // external_interface.BCLK
		.AUD_DACDAT(AUD_DACDAT),  //                   .DACDAT
		.AUD_DACLRCK(AUD_DACLRCK), //                   .DACLRCK
//		output wire        irq,         //          interrupt.irq
		.reset (audio_rst)		       //              reset.reset
	);

// IP to auto-config the AV chip
audio_config (
//		input  wire [1:0]  address,     // avalon_av_config_slave.address
//		input  wire [3:0]  byteenable,  //                       .byteenable
//		input  wire        read,        //                       .read
//		input  wire        write,       //                       .write
//		input  wire [31:0] writedata,   //                       .writedata
//		output wire [31:0] readdata,    //                       .readdata
//		output wire        waitrequest, //                       .waitrequest
		.clk(CLOCK_50),         //                    clk.clk
		.I2C_SDAT(FPGA_I2C_SDAT),    //     external_interface.SDAT
		.I2C_SCLK(FPGA_I2C_SCLK),    //                       .SCLK
		.reset(audio_rst)        //                  reset.reset
	);

endmodule
