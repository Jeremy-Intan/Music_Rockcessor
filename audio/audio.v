
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module audio(

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);


//TODO: make it less of a vaccuum cleaner/random
// figure out why it's only playing during reset (queue over filled/not reading?)
// make buttons do different frequencies to DAC while switches control frequency?

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire audio_rst;
wire [15:0] amplitude;

reg [1:0] write_addr;

reg [20:0] counter = 0;
reg [20:0] counter_depth;
reg [15:0] write_wave;

/*
reg [20:0] t_counter1 = 0;
reg [20:0] t_counter2 = 0;
reg [20:0] t_counter3 = 0;
reg [1:0] chord_matches;
wire [15:0] test_amp;
wire [20:0] chord_test;
localparam mult_1 = 191117;
localparam mult_2 = 151690;
localparam mult_3 = 127551;
*/

//=======================================================
//  Structural coding
//=======================================================

// use push buttons for volume of sound. No sound if no button being pressed
assign amplitude = (~KEY[1]) ? 16'h7FFF : (~KEY[2]) ? 16'h5FFF : (~KEY[3]) ? 16'h3FFF : 16'h0000;

// light up when reset is active
assign LEDR[0] = ~KEY[0];
	
always @ (posedge CLOCK_50) begin
	// set counter depth based on switches
	// values are calculated for the 50 Mhz clock. 50 Mhz / ({desired frequency}) = counter value
	// Audio chip's sampling rate and clock shouldn't effect which single note is being played
   counter_depth <= (SW[0]) ? 191117 : (SW[1]) ? 170265 : (SW[2]) ? 151690 : (SW[3]) ? 143176 : (SW[4]) ? 127551 : (SW[5]) ? 113636 : (SW[6]) ? 101239 : (SW[7]) ? 95555 : (SW[8]) ? 47778 : (SW[9]) ? 382204 : 1;
	// handle resets
	if (~KEY[0]) begin
		write_wave <= 16'h0000;
		counter <= 20'h00000;
	end
	else begin
		// set 50% duty cycle for a square wave. Could try and make a cosine wave later. 
		if (counter <= (counter_depth >> 1))
			write_wave <= amplitude;
		else
			write_wave <= 20'h00000;
		// control the counter for note
		if (counter >= counter_depth)
			counter <= 20'h00000;
		else
			counter <= counter + 1;
	end
	
//	write same data to the right and left sides  
// (doesn't change frequency stuff above for some reason. Should double counter?)
	if (write_addr == 2'b10)
		write_addr <= 2'b11;
	else
		write_addr <= 2'b10;
		
end



// IP to generate a slower clock for the AV chip
audio_clk (
		.audio_clk_clk(AUD_XCK),      //    audio_clk.clk
		.ref_clk_clk(CLOCK_50),        //      ref_clk.clk
		.ref_reset_reset(~KEY[0]),    //    ref_reset.reset
		.reset_source_reset(audio_rst)  // reset_source.reset
	);

// IP to output through AV chip
audio_output (
		.address(write_addr),     // avalon_audio_slave.address
		.chipselect(1'b1),  //                   .chipselect
//		input  wire        read,        //                   .read
		.write(1'b1),       //                   .write
		//.writedata({16'b0,chord_test}),
		.writedata({16'b0,write_wave}),
//		output wire [31:0] readdata,    //                   .readdata
		//.clk(AUD_XCK),         //                clk.clk
		.clk(CLOCK_50),
		.AUD_BCLK(AUD_BCLK),    // external_interface.BCLK
		.AUD_DACDAT(AUD_DACDAT),  //                   .DACDAT
		.AUD_DACLRCK(AUD_DACLRCK), //                   .DACLRCK
//		output wire        irq,         //          interrupt.irq
		.reset (audio_rst)		       //              reset.reset
	);

// IP to auto-config the AV chip
audio_config (
//		input  wire [1:0]  address,     // avalon_av_config_slave.address
//		input  wire [3:0]  byteenable,  //                       .byteenable
//		input  wire        read,        //                       .read
//		input  wire        write,       //                       .write
//		input  wire [31:0] writedata,   //                       .writedata
//		output wire [31:0] readdata,    //                       .readdata
//		output wire        waitrequest, //                       .waitrequest
		.clk(CLOCK_50),         //                    clk.clk
		.I2C_SDAT(FPGA_I2C_SDAT),    //     external_interface.SDAT
		.I2C_SCLK(FPGA_I2C_SCLK),    //                       .SCLK
		.reset(audio_rst)        //                  reset.reset
	);
	
/*
	// test when all the switches are off. If so, amplitude gets the added value from 3 counters making the chord. otherwise, it's just one.
	assign chord_test = (SW[0] | SW[1] | SW[2] | SW[3] | SW[4] | SW[5] | SW[6] | SW[7] | SW[8] | SW[9]) ?  write_wave : test_amp;
	assign test_amp = (~KEY[1]) ? 16'h7FFF>>(3-chord_matches) : (~KEY[2]) ? 16'h5FFF>>(3-chord_matches) : (~KEY[3]) ? 16'h3FFF>>(3-chord_matches) : 16'h0000;
	// if there are 3 matched chords, play loud. Otherwise scale back assuming even volume for each wave.
	always @ (posedge CLOCK_50) begin
		if (~KEY[0]) begin
			t_counter1 <= 20'h00000;
			t_counter2 <= 20'h00000;
			t_counter3 <= 20'h00000;
		end
		else begin 
			t_counter1 <= t_counter1 + 1;
			t_counter2 <= t_counter2 + 1;
			t_counter3 <= t_counter3 + 1;
			if (t_counter1 >= mult_1)
				t_counter1 <= 20'h00000;
			if (t_counter2 >= mult_2)
				t_counter1 <= 20'h00000;
			if (t_counter3 >= mult_3)
				t_counter1 <= 20'h00000;
			if ((t_counter1 <= (mult_1 >> 1)) && (t_counter2 <= (mult_2 >> 1)) && (t_counter3 <= (mult_3 >> 1)))
				chord_matches = 3;
			else if (((t_counter1 <= (mult_1 >> 1)) && (t_counter2 <= (mult_2 >> 1))) || ((t_counter1 <= (mult_1 >> 1)) && (t_counter3 <= (mult_3 >> 1))) || ((t_counter2 <= (mult_2 >> 1)) && (t_counter3 <= (mult_3 >> 1))))
				chord_matches = 2;
			else if ((t_counter1 <= (mult_1 >> 1)) || (t_counter2 <= (mult_2 >> 1)) || (t_counter3 <= (mult_3 >> 1)))
				chord_matches = 1;
			else
				chord_matches = 0;
		end
	
	end
*/
endmodule
